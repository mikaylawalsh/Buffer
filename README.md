# buffer

Note: There are some in line comments in the txt files and asm code, but the full 
explanations for each level will be here. 

Level 1: For this level, there were two main things I had to figure out: (1) what is the size of the buffer and (2) what is the address we want to return to instead. The second one was easy to find. Since we knew we wanted to return to the lights_off function in buffer, all I had to do was look at the disassembled code in my obj.txt file. Here I found the lights_out function and got the address of its starting point. In my case, it was 00000000004010a0. Next, I knew this value had to come after my buffer and the old rbp in my exploit string since the return address comes right before the old rbp which comes right beofre the buffer in memory and the exploit string writes from bottom to top. Additionally, however, since the machines we are using are little-endian I had to reverse this address so the least significant byte would be read first. Since every two of these numbers is a byte the line after my buffer in my exploit string would be a0 10 40 00 00 00 00 00. From here, I had to figure out the size of my buffer. I found this again by looking at my disassembled code. In the getbuf function, the fourth line in makes this call: lea    -0x50(%rbp),%rdi. This is the line where space is allocated for the buffer. This is the diffence between the start of the rbp and the beginning of buffer. That means that 0x50 is the size of the buffer and this converted to decimal is 80. So I needed 80 bytes of padding before and then an additional 8 bytes to bypass the old rbp. After that would come the return address we found ealier. So in the end, we would have 88 bytes of no-ops to fill up the buffer and bypass the old rbp and then 8 bytes of the new return address to lights_out. 

Level 2: This level was very similar to the last one. The logic for lines 1 to 12 in the exploit string is the same as for level one. There was the 80 byte buffer, then 8 bytes to bypass the old rbp, and then 8 bytes for the new return address. Lines 13-16 are used to set the number of sandwiches. The struct sandwich_order has two components: the id and the sammich_types array. The id we wanted to set to be our cookie which is done on line 14. The sammich_types array comes directly after the id in memory. Since the id and each of the 4 elements of the array are ints, they each get 4 bytes in memory. I set each of the elements to be 20 in order to ensure that there was enough sandwiches. The reason the id and sammich_types come after the buffer and return address in the string is becuse they come before it in memory. The arguments of the function sandwich_order are set in the previous function, so we can overwrite them this way. However, there is padding that is necessary in order to make sure that we are overwriting the correct arguments. We can find this the same way we found the size of the buffer above. When looking in sandwich_order, there is a line  that reads lea    0x10(%rbp),%rax; 0x10 in decimal is 8, so we need 8 bytes of padding. This padding goes between our return address and arguments. In the end, we have 80 bytes of our buffer, 8 bytes of the old rbp, 8 bytes of our return address, 8 bytes of padding, 4 bytes of our cookie/id, and then 4 more 4-byte ints to set the sammich-types array. 

Level 3: The first thing we had to do for this level was write some asm code. All we wanted to do for this level was return our cookie. So all the code needed to do was move our cookie into the register which is returned, which as we know is rax. The first thing we did was push the old rbp which is the place we want to return to. So we found this by taking the address of the line that comes directly after the call to getbuf, which in this case was 0x4011c5. Next, we moved our coookie into rax and then return from the function. This is the code we want to excute instead of the return address. The size of the buffer is the same as the previous levels, however this time, we want our assembly code to be part of the buffer so that it is executed. The asm code can go anywhere in the buffer, but I chose to put it at the end. (In order to get the asm code into hex so we can use it in our string I needed to compile it with gcc -c lost.s and then disassemble it using objdump -d lost.o > lost.d. From here we could delete the line numbers and comment out the asm code to just have the hex values.) The asm code turned out to be 13 bytes long. This means we have 67 bytes of the no-ops and then the 13 bytes of our asm code to fill the buffer. The next two lines are the same as they have been: the old rbp and the new address we want to return to. To find the old rbp to return to after the function, we had to step through the gdb. I set a breakpoint at test_exploit and then printed the rbp at the beginning of the function. I found it was 55782fe0, so I reversed this (litte-endian) and put it in the exploit string. The last thing I needed was the new address. We wanted to execute the code in our buffer, so I needed to find the starting point of the buffer. The way we found the size of our buffer in each of the levels is by looking at the line lea    -0x50(%rbp),%rdi. What we need to look at in order to find the address of the buffer is rdi. That is what the offset of rbp is being moved into. So, I set a breakpoint at getbuf and then ran the gdb and printed out the rdi. I found it was 55782f60 and then revesed it and put it in the string.

Level 4: The process for this last level was relatively similar to level 3, but required a little more work. We had to be careful about restoring the canary to make sure we were not detected changing the stack. Additionally, we had to account for all the different stack positions. Again the first thing we had to do was write some asm code. It was relatively similar to our lost code, but we needed to restore to canary as well. That is the first thing we do in our asm code. By looking at the test_exploitn code, we can see that we subtract 0x20 from the rsp and that address is what is used in uniqueval. This means that it is where our canary is stored. So, in order to access this address, we move an offest of 0x20 from rsp into the rbp in order to restore the canary. The next three lines are the exact same as the last level: we move our cookie into rax, push the old rbp where we want to return to after the exploit, and return. We find the hex values in the same way as level 3 and use that in our exploit string. The next challenge was finding the size of the buffer which we do the same as before. In getbufn, we see this line of code lea    -0x220(%rbp),%rdi. 0x220 in decimal is 544, so that is the size of our buffer. Our asm code for this level is 18 bytes long, so we need 526 bytes of no-ops in order to fill the rest of the buffer. This time, the asm code needs to come at the end of of our exploit string. Since there is a range (max of 240 difference between runs) of values our stack could be at. That means matter where in our buffer it lands, it will eventually hit our exploit code. This is called a nop sled. After our buffer, we again need to handle the old rbp and then address we want to jump to. Since we handle the old rbp in our asm code, we can just fill this with 8 bytes of padding to bypass it. Lastly, we again need the address of the beginning of our buffer that we want to jump to. This is slightly more difficult this time because our values can change. I took the same approach I did in level 3 and printed out the rdi value, but this time I ran the gbd with the -n flag and could print out 5 different rdi values. I tested each of these in exploit string to see which would work. It would work only if the address was in a "sweet spot" that allowed it to always land somewhere in the nop sled. This turned out to be the largest of the rdi values which makes sense because it will always land somewhere in the nop sled and never jumps over the exploit code. In the end, we have 526 bytes of no-ops to fill the buffer, 18 bytes of exploit code, 8 bytes of paddding to bypass old rbp, and 8 bytes which is the address we will jump to. 
